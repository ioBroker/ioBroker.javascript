{"version":3,"file":"patternCompareFunctions.js","sourceRoot":"","sources":["../../src/lib/patternCompareFunctions.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Pattern } from '../types';\nimport { type EventObj } from './eventObj';\n\nfunction isRegExp(obj: any): boolean {\n    return !!(obj?.test && obj.exec && (obj.ignoreCase || obj.ignoreCase === false));\n}\n\nexport type PatternEventCompareFunction = (event: EventObj) => boolean;\n\n/**\n * @param pattern The pattern object to use\n * @param propName The name of the property to compare\n * @param eventPropertyExtractor If given, this function is used to extract the property value from the event object. Otherwise, the propName is used\n * @param invert Whether to invert the result\n */\nfunction stringOrRegExpCompare(\n    pattern: Pattern,\n    propName: string,\n    eventPropertyExtractor?: (event: EventObj) => any,\n    invert?: boolean,\n): PatternEventCompareFunction {\n    const field: RegExp | string | string[] = (pattern as Record<string, RegExp | string | string[]>)[propName];\n    const hasExtractor = typeof eventPropertyExtractor === 'function';\n\n    if (isRegExp(field)) {\n        return function (event: EventObj): boolean {\n            const eventValue: any = hasExtractor\n                ? eventPropertyExtractor(event)\n                : (event as Record<string, any>)[propName];\n            const ret = eventValue != null && (field as RegExp).test(eventValue);\n            return invert ? !ret : ret;\n        };\n    }\n\n    if (Array.isArray(field)) {\n        return function (event: EventObj): boolean {\n            const eventValue = hasExtractor ? eventPropertyExtractor(event) : (event as Record<string, any>)[propName];\n            // An array matches when any element is found that satisfies the constraint\n            const ret = eventValue != null && field.find(f => f === eventValue) != null;\n            return invert ? !ret : ret;\n        };\n    }\n\n    return function (event: EventObj): boolean {\n        const eventValue = hasExtractor ? eventPropertyExtractor(event) : (event as Record<string, any>)[propName];\n        const ret = eventValue != null && field === eventValue;\n        return invert ? !ret : ret;\n    };\n}\n\nexport const patternCompareFunctions = {\n    logic: (_pattern: Pattern): void => {},\n\n    id: (pattern: Pattern): PatternEventCompareFunction => stringOrRegExpCompare(pattern, 'id'),\n\n    name: (pattern: Pattern): PatternEventCompareFunction => stringOrRegExpCompare(pattern, 'name'),\n\n    change: (pattern: Pattern): PatternEventCompareFunction => {\n        switch (pattern.change) {\n            case 'eq':\n                return (event: EventObj): boolean => event.newState.val === event.oldState.val;\n            case 'ne':\n                return (event: EventObj): boolean => event.newState.val !== event.oldState.val;\n            case 'gt':\n                // @ts-expect-error we assume it could be null\n                return (event: EventObj): boolean => event.newState.val > event.oldState.val;\n            case 'ge':\n                // @ts-expect-error we assume it could be null\n                return (event: EventObj): boolean => event.newState.val >= event.oldState.val;\n            case 'lt':\n                // @ts-expect-error we assume it could be null\n                return (event: EventObj): boolean => event.newState.val < event.oldState.val;\n            case 'le':\n                // @ts-expect-error we assume it could be null\n                return (event: EventObj): boolean => event.newState.val <= event.oldState.val;\n            default:\n                return (_event: EventObj): boolean => true;\n            // on any other logic, just signal about a message\n        }\n    },\n\n    ack: (pattern: Pattern): PatternEventCompareFunction => {\n        if (pattern.ack === true || pattern.ack === 'true') {\n            return (event: EventObj): boolean => event.newState.ack === true;\n        }\n        return (event: EventObj): boolean => event.newState.ack === false;\n    },\n    oldAck: (pattern: Pattern): PatternEventCompareFunction => {\n        if (pattern.oldAck === true || pattern.oldAck === 'true') {\n            return (event: EventObj): boolean => event.oldState.ack === true;\n        }\n        return (event: EventObj): boolean => event.oldState.ack === false;\n    },\n\n    q: (pattern: Pattern): PatternEventCompareFunction => {\n        const q = pattern.q;\n        return (event: EventObj): boolean => q === '*' || q === event.newState.q;\n    },\n    oldQ: (pattern: Pattern): PatternEventCompareFunction => {\n        const q = pattern.oldQ;\n        return (event: EventObj): boolean => q === '*' || q === event.oldState.q;\n    },\n\n    val: (pattern: Pattern): PatternEventCompareFunction => {\n        const pVal = pattern.val;\n        return (event: EventObj): boolean => pVal === event.newState.val;\n    },\n    valGt: (pattern: Pattern): PatternEventCompareFunction => {\n        const pValGt = pattern.valGt;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.newState.val > pValGt;\n    },\n    valGe: (pattern: Pattern): PatternEventCompareFunction => {\n        const pValGe = pattern.valGe;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.newState.val >= pValGe;\n    },\n    valLt: (pattern: Pattern): PatternEventCompareFunction => {\n        const pValLt = pattern.valLt;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.newState.val < pValLt;\n    },\n    valLe: (pattern: Pattern): PatternEventCompareFunction => {\n        const pValLe = pattern.valLe;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.newState.val <= pValLe;\n    },\n    valNe: (pattern: Pattern): PatternEventCompareFunction => {\n        const pValNe = pattern.valNe;\n        return (event: EventObj): boolean => event.newState.val !== pValNe;\n    },\n\n    oldVal: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldVal = pattern.oldVal;\n        return (event: EventObj): boolean => pOldVal === event.oldState.val;\n    },\n    oldValGt: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldValGt = pattern.oldValGt;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.oldState.val > pOldValGt;\n    },\n    oldValGe: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldValGe = pattern.oldValGe;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.oldState.val >= pOldValGe;\n    },\n    oldValLt: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldValLt = pattern.oldValLt;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.oldState.val < pOldValLt;\n    },\n    oldValLe: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldValLe = pattern.oldValLe;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.oldState.val <= pOldValLe;\n    },\n    oldValNe: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldValNe = pattern.oldValNe;\n        return (event: EventObj): boolean => event.oldState.val !== pOldValNe;\n    },\n\n    ts: (pattern: Pattern): PatternEventCompareFunction => {\n        const pts = pattern.ts;\n        return (event: EventObj): boolean => pts === event.newState.ts;\n    },\n    tsGt: (pattern: Pattern): PatternEventCompareFunction => {\n        const ptsGt = pattern.tsGt;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.newState.ts > ptsGt;\n    },\n    tsGe: (pattern: Pattern): PatternEventCompareFunction => {\n        const ptsGe = pattern.tsGe;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.newState.ts >= ptsGe;\n    },\n    tsLt: (pattern: Pattern): PatternEventCompareFunction => {\n        const ptsLt = pattern.tsLt;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.newState.ts < ptsLt;\n    },\n    tsLe: (pattern: Pattern): PatternEventCompareFunction => {\n        const ptsLe = pattern.tsLe;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.newState.ts <= ptsLe;\n    },\n\n    oldTs: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldTs = pattern.oldTs;\n        return (event: EventObj): boolean => pOldTs === event.oldState.ts;\n    },\n    oldTsGt: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldTsGt = pattern.oldTsGt;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.oldState.ts > pOldTsGt;\n    },\n    oldTsGe: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldTsGe = pattern.oldTsGe;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.oldState.ts >= pOldTsGe;\n    },\n    oldTsLt: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldTsLt = pattern.oldTsLt;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.oldState.ts < pOldTsLt;\n    },\n    oldTsLe: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldTsLe = pattern.oldTsLe;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.oldState.ts <= pOldTsLe;\n    },\n\n    lc: (pattern: Pattern): PatternEventCompareFunction => {\n        const plc = pattern.lc;\n        return (event: EventObj): boolean => plc === event.newState.lc;\n    },\n    lcGt: (pattern: Pattern): PatternEventCompareFunction => {\n        const plcGt = pattern.lcGt;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.newState.lc > plcGt;\n    },\n    lcGe: (pattern: Pattern): PatternEventCompareFunction => {\n        const plcGe = pattern.lcGe;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.newState.lc >= plcGe;\n    },\n    lcLt: (pattern: Pattern): PatternEventCompareFunction => {\n        const plcLt = pattern.lcLt;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.newState.lc < plcLt;\n    },\n    lcLe: (pattern: Pattern): PatternEventCompareFunction => {\n        const plcLe = pattern.lcLe;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.newState.lc <= plcLe;\n    },\n\n    oldLc: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldLc = pattern.oldLc;\n        return (event: EventObj): boolean => pOldLc === event.oldState.lc;\n    },\n    oldLcGt: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldLcGt = pattern.oldLcGt;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.oldState.lc > pOldLcGt;\n    },\n    oldLcGe: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldLcGe = pattern.oldLcGe;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.oldState.lc >= pOldLcGe;\n    },\n    oldLcLt: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldLcLt = pattern.oldLcLt;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.oldState.lc < pOldLcLt;\n    },\n    oldLcLe: (pattern: Pattern): PatternEventCompareFunction => {\n        const pOldLcLe = pattern.oldLcLe;\n        // @ts-expect-error we assume it could be null\n        return (event: EventObj): boolean => event.oldState.lc <= pOldLcLe;\n    },\n\n    from: (pattern: Pattern): PatternEventCompareFunction =>\n        stringOrRegExpCompare(pattern, 'from', event => event && event.newState && event.newState.from),\n\n    fromNe: (pattern: Pattern): PatternEventCompareFunction =>\n        stringOrRegExpCompare(pattern, 'fromNe', event => event && event.newState && event.newState.from, true),\n\n    oldFrom: (pattern: Pattern): PatternEventCompareFunction =>\n        stringOrRegExpCompare(pattern, 'oldFrom', event => event && event.oldState && event.oldState.from),\n\n    oldFromNe: (pattern: Pattern): PatternEventCompareFunction =>\n        stringOrRegExpCompare(pattern, 'oldFromNe', event => event && event.oldState && event.oldState.from, true),\n\n    channelId: (pattern: Pattern): PatternEventCompareFunction => stringOrRegExpCompare(pattern, 'channelId'),\n    channelName: (pattern: Pattern): PatternEventCompareFunction => stringOrRegExpCompare(pattern, 'channelName'),\n    deviceId: (pattern: Pattern): PatternEventCompareFunction => stringOrRegExpCompare(pattern, 'deviceId'),\n    deviceName: (pattern: Pattern): PatternEventCompareFunction => stringOrRegExpCompare(pattern, 'deviceName'),\n\n    enumId: (pattern: Pattern): PatternEventCompareFunction => {\n        const pEnumId: RegExp | string | string[] | undefined = pattern.enumId;\n\n        function ensureEnumIDsIsArray(enumIds: any): boolean {\n            if (!Array.isArray(enumIds)) {\n                console.error(\n                    `enumIds is of type ${typeof enumIds} but should be an array: ${JSON.stringify(enumIds)}`,\n                );\n                return false;\n            }\n            return true;\n        }\n\n        if (isRegExp(pEnumId)) {\n            return (event: EventObj): boolean => {\n                const enumIds = event.enumIds;\n                if (enumIds == null || !ensureEnumIDsIsArray(enumIds)) {\n                    return false;\n                }\n                // Test if any enum name matches the regex:\n                return enumIds.find(e => (pEnumId as RegExp).test(e)) != null;\n            };\n        }\n\n        if (Array.isArray(pEnumId)) {\n            return (event: EventObj): boolean => {\n                const enumIds = event.enumIds;\n                if (enumIds == null || !ensureEnumIDsIsArray(enumIds)) {\n                    return false;\n                }\n                // Test if the enum names of the event and the given array intersect\n                return enumIds.find(e => pEnumId.includes(e)) != null;\n            };\n        }\n\n        return (event: EventObj): boolean => {\n            const enumIds = event.enumIds;\n            if (enumIds == null || !ensureEnumIDsIsArray(enumIds)) {\n                return false;\n            }\n            return enumIds && enumIds.includes(pEnumId as string);\n        };\n    },\n\n    enumName: (pattern: Pattern): PatternEventCompareFunction => {\n        const pEnumName: RegExp | string | string[] | undefined = pattern.enumName;\n\n        function ensureEnumNamesIsArray(enumNames: any): boolean {\n            if (!Array.isArray(enumNames)) {\n                console.error(\n                    `enumNames is of type ${typeof enumNames} but should be an array: ${JSON.stringify(enumNames)}`,\n                );\n                return false;\n            }\n            return true;\n        }\n\n        if (isRegExp(pEnumName)) {\n            return (event: EventObj): boolean => {\n                const enumNames = event.enumNames;\n                if (enumNames == null || !ensureEnumNamesIsArray(enumNames)) {\n                    return false;\n                }\n                // Test if any enum name matches the regex:\n                return enumNames.find(e => (pEnumName as RegExp).test(e)) != null;\n            };\n        }\n        if (Array.isArray(pEnumName)) {\n            return (event: EventObj): boolean => {\n                const enumNames = event.enumNames;\n                if (enumNames == null || !ensureEnumNamesIsArray(enumNames)) {\n                    return false;\n                }\n                // Test if the enum names of the event and the given array intersect\n                return enumNames.find(e => pEnumName.includes(e)) != null;\n            };\n        }\n\n        return (event: EventObj): boolean => {\n            const enumNames = event.enumNames;\n            if (enumNames == null || !ensureEnumNamesIsArray(enumNames)) {\n                return false;\n            }\n            return enumNames?.includes(pEnumName as string);\n        };\n    },\n};\n"]}