{"version":3,"file":"tools.js","sourceRoot":"","sources":["../../src/lib/tools.ts"],"names":[],"mappings":"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","sourcesContent":["// import { readdirSync, statSync } from 'node:fs';\n// import { join } from 'node:path';\nimport { createHash } from 'node:crypto';\nimport { Agent } from 'node:https';\nimport type { AxiosRequestConfig, ResponseType } from 'axios';\n\n/**\n * Tests whether the given variable is a real object and not an Array\n *\n * @param it The variable to test\n */\nexport function isObject(it: any): boolean {\n    // This is necessary because:\n    // typeof null === 'object'\n    // typeof [] === 'object'\n    // [] instanceof Object === true\n    return Object.prototype.toString.call(it) === '[object Object]';\n}\n\n/**\n * Tests whether the given variable is really an Array\n *\n * @param it The variable to test\n */\nexport function isArray(it: any): boolean {\n    return Array.isArray(it);\n}\n\n/**\n * Finds all matches of a regular expression and returns the matched groups\n *\n * @param regex The regular expression to match against the string\n * @param string The string to test\n */\nexport function matchAll(regex: RegExp, string: string): string[][] {\n    const ret: string[][] = [];\n    let match: RegExpExecArray | null;\n    do {\n        match = regex.exec(string);\n        if (match) {\n            ret.push(match.slice(1));\n        }\n    } while (match);\n\n    return ret;\n}\n\n/**\n * Enumerates all files matching a given predicate\n *\n * @param rootDir The directory to start in\n * @param predicate A function that takes a filename and returns true if the file should be included\n */\n/*export function enumFilesRecursiveSync(rootDir: string, predicate: (filename: string) => boolean): string[] {\n    const ret: string[] = [];\n    try {\n        const filesAndDirs = readdirSync(rootDir);\n        for (const f of filesAndDirs) {\n            const fullPath = join(rootDir, f);\n\n            if (statSync(fullPath).isDirectory()) {\n                Array.prototype.push.apply(ret, enumFilesRecursiveSync(fullPath, predicate));\n            } else if (typeof predicate === 'function' && predicate(fullPath)) {\n                ret.push(fullPath);\n            }\n        }\n    } catch (err: unknown) {\n        console.error(`Cannot read directory: \"${rootDir}\": ${err as Error}`);\n    }\n\n    return ret;\n}*/\n\n/**\n * Promisifies a callback-style function with parameters (err, result)\n *\n * @param  fn The callback-style function to promisify\n * @param context The value of `this` in the function\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport function promisify(fn: Function, context?: any): (...args: any[]) => Promise<any> {\n    return function (...args) {\n        // @ts-expect-error We want this behavior\n        context = context || this;\n        return new Promise((resolve, reject) => {\n            try {\n                fn.apply(context, [\n                    ...args,\n                    (error: Error | string | null, result: null) => {\n                        if (error) {\n                            if (typeof error === 'string') {\n                                return reject(new Error(error));\n                            }\n                            return reject(error);\n                        }\n                        return resolve(result);\n                    },\n                ]);\n            } catch (error: unknown) {\n                reject(error as Error);\n            }\n        });\n    };\n}\n\n/**\n * Promisifies a callback-style function without an error parameter\n *\n * @param fn The callback-style function to promisify\n * @param context The value of `this` in the function\n */\n/*\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport function promisifyNoError(fn: Function, context: any): (...args: any[]) => Promise<any> {\n    return function (...args) {\n        // @ts-expect-error We want this behavior\n        context = context || this;\n        return new Promise(resolve => {\n            try {\n                fn.apply(context, [...args, (result: any) => resolve(result)]);\n            } catch {\n                resolve(null); // what to do in this case??\n            }\n        });\n    };\n}*/\n\n/**\n * Creates an MD5 hash of a script source which can be used to check whether the source of a compiled language changed\n *\n * @param source The source code to hash\n */\nexport function hashSource(source: string | Buffer): string {\n    return createHash('md5').update(source).digest('hex');\n}\n\nexport function getHttpRequestConfig(\n    url: string,\n    options?: {\n        timeout?: number;\n        responseType?: ResponseType;\n        headers?: Record<string, string>;\n        basicAuth?: { user: string; password: string } | null;\n        bearerAuth?: string;\n        validateCertificate?: boolean;\n    },\n): AxiosRequestConfig {\n    options = options || {};\n    const timeoutMs = options && !isNaN(options.timeout as number) ? options.timeout : 2000;\n\n    const config: AxiosRequestConfig = {\n        method: 'get',\n        url,\n        validateStatus: (status: number): boolean => status >= 200,\n        responseType: options && options.responseType ? options.responseType : 'text',\n        responseEncoding: 'utf8',\n        timeout: timeoutMs,\n        //signal: AbortSignal.timeout(timeoutMs), // connection related timeouts\n    };\n\n    options.headers = options.headers || {};\n\n    if (options && options.basicAuth) {\n        config.auth = {\n            username: options.basicAuth.user,\n            password: options.basicAuth.password,\n        };\n    } else if (options.bearerAuth) {\n        options.headers.Authorization = `Bearer ${options.bearerAuth}`;\n    } else {\n        const uri = new URL(url);\n        if (uri.username && uri.password) {\n            const username = decodeURIComponent(uri.username);\n            const password = decodeURIComponent(uri.password);\n\n            config.url = (config.url || '').replace(`${uri.protocol}//${username}:${password}@`, `${uri.protocol}//`);\n            config.auth = {\n                username,\n                password,\n            };\n        }\n    }\n\n    // Set default headers\n    config.headers = {\n        'User-Agent': 'Mozilla/5.0 (X11; Linux i686; rv:109.0) Gecko/20100101 Firefox/121.0',\n        ...options.headers,\n    };\n\n    // Certificate validation\n    if (options && typeof options?.validateCertificate !== 'undefined') {\n        config.httpsAgent = new Agent({\n            rejectUnauthorized: options.validateCertificate,\n        });\n    }\n\n    return config;\n}\n"]}