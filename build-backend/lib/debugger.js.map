{"version":3,"file":"debugger.js","sourceRoot":"","sources":["../../src/lib/debugger.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Node.js contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\nimport { join, resolve } from 'node:path';\nimport { type ReplOptions, type REPLServer, start } from 'repl';\nimport {\n    debuglog as debuglogUtil,\n    inspect as inspectUtil,\n    type InspectOptions,\n    type InspectOptionsStylized,\n    type Style,\n} from 'node:util';\nimport { type Context, runInContext } from 'node:vm';\nimport { fileURLToPath } from 'node:url';\nimport { builtinModules as PUBLIC_BUILTINS } from 'node:module';\nimport type { Debugger, Runtime } from 'node:inspector';\n\nimport type { NodeInspector } from './inspect';\n\nconst debuglog = debuglogUtil('inspect');\n\ninterface PropertyPreview {\n    /**\n     * Property name.\n     */\n    name: string;\n    /**\n     * Object type. Accessor means that the property itself is an accessor property.\n     */\n    type: string;\n    /**\n     * User-friendly property value string.\n     */\n    value?: string | undefined;\n    /**\n     * Object subtype hint. Specified for <code>object</code> type values only.\n     */\n    subtype?: string | undefined;\n}\n/*const SHORTCUTS = {\n    cont: 'c',\n    next: 'n',\n    step: 's',\n    out: 'o',\n    backtrace: 'bt',\n    setBreakpoint: 'sb',\n    clearBreakpoint: 'cb',\n    run: 'r',\n};\n\nconst HELP = `\nrun, restart, r       Run the application or reconnect\nkill                  Kill a running application or disconnect\n\ncont, c               Resume execution\nnext, n               Continue to next line in current file\nstep, s               Step into, potentially entering a function\nout, o                Step out, leaving the current function\nbacktrace, bt         Print the current backtrace\nlist                  Print the source around the current line where execution\n                      is currently paused\n\nsetBreakpoint, sb     Set a breakpoint\nclearBreakpoint, cb   Clear a breakpoint\nbreakpoints           List all known breakpoints\nbreakOnException      Pause execution whenever an exception is thrown\nbreakOnUncaught       Pause execution whenever an exception isn't caught\nbreakOnNone           Don't pause on exceptions (this is the default)\n\nwatch(expr)           Start watching the given expression\nunwatch(expr)         Stop watching an expression\nwatchers              Print all watched expressions and their current values\n\nexec(expr)            Evaluate the expression and print the value\nrepl                  Enter a debug repl that works like exec\n\nscripts               List application scripts that are currently loaded\nscripts(true)         List all scripts (including node-internals)\n\nprofile               Start CPU profiling session.\nprofileEnd            Stop current CPU profiling session.\nprofiles              Array of completed CPU profiling sessions.\nprofiles[n].save(filepath = 'node.cpuprofile')\n                      Save CPU profiling session to disk as JSON.\n\ntakeHeapSnapshot(filepath = 'node.heapsnapshot')\n                      Take a heap snapshot and save to disk as JSON.\n`.trim();*/\n\nconst FUNCTION_NAME_PATTERN = /^(?:function\\*? )?([^(\\s]+)\\(/;\nfunction extractFunctionName(description: string | undefined): string {\n    const fnNameMatch = description?.match(FUNCTION_NAME_PATTERN);\n    return fnNameMatch ? `: ${fnNameMatch[1]}` : '';\n}\n\n// process.binding is a method available on the process object, which allows you to load internal modules written in C++\n// @ts-expect-error binding is internal function\nconst NATIVES = PUBLIC_BUILTINS ? process.binding('natives') : {};\n\nfunction isNativeUrl(url: string): boolean {\n    url = url.replace(/\\.js$/, '');\n    if (PUBLIC_BUILTINS) {\n        if (url.startsWith('internal/') || PUBLIC_BUILTINS.includes(url)) {\n            return true;\n        }\n    }\n\n    return url in NATIVES || url === 'bootstrap_node';\n}\n\nfunction getRelativePath(filenameOrURL: string): string {\n    const dir = join(resolve(), 'x').slice(0, -1);\n\n    const filename = filenameOrURL.startsWith('file://') ? fileURLToPath(filenameOrURL) : filenameOrURL;\n\n    // Change a path to relative, if possible\n    if (filename.indexOf(dir) === 0) {\n        return filename.slice(dir.length);\n    }\n    return filename;\n}\n\nfunction toCallback(promise: Promise<any>, callback: (...args: any[]) => void): void {\n    function forward(...args: any[]): void {\n        process.nextTick(() => callback(...args));\n    }\n\n    promise.then(forward.bind(null, null), forward);\n}\n\n// Adds spaces and prefix to number\n// maxN is a maximum number we should have space for\nfunction leftPad(n: number, prefix: string, maxN: number): string {\n    const s = n.toString();\n    const nchars = Math.max(2, String(maxN).length) + 1;\n    const nspaces = nchars - s.length - 1;\n\n    return prefix + ' '.repeat(nspaces) + s;\n}\n\nfunction markSourceColumn(sourceText: string, position: number, useColors?: boolean): string {\n    if (!sourceText) {\n        return '';\n    }\n\n    const head = sourceText.slice(0, position);\n    let tail = sourceText.slice(position);\n\n    // Colorize char if stdout supports colours\n    if (useColors) {\n        tail = tail.replace(/(.+?)([^\\w]|$)/, '\\u001b[32m$1\\u001b[39m$2');\n    }\n\n    // Return source line with coloured char at `position`\n    return [head, tail].join('');\n}\n\nfunction extractErrorMessage(stack: string | undefined): string {\n    if (!stack) {\n        return '<unknown>';\n    }\n    const m = stack.match(/^\\w+: ([^\\n]+)/);\n    return m ? m[1] : stack;\n}\n\nfunction convertResultToError(result: Runtime.RemoteObject): Error {\n    const { className, description } = result;\n    const err = new Error(extractErrorMessage(description));\n    err.stack = description;\n    Object.defineProperty(err, 'name', { value: className });\n    return err;\n}\n\nclass RemoteObject implements Runtime.RemoteObject {\n    type: string;\n    subtype?: string | undefined;\n    className?: string | undefined;\n\n    value: any;\n    unserializableValue?: Runtime.UnserializableValue | undefined;\n    description: string | undefined;\n    objectId?: Runtime.RemoteObjectId | undefined;\n    preview?: Runtime.ObjectPreview | undefined;\n    customPreview?: Runtime.CustomPreview | undefined;\n\n    constructor(attributes: Runtime.RemoteObject | undefined) {\n        this.type = 'undefined';\n        Object.assign(this, attributes);\n        if (this.type === 'number') {\n            this.value = this.unserializableValue ? +this.unserializableValue : +this.value;\n        }\n    }\n\n    [inspectUtil.custom](_depth: number, opts: InspectOptionsStylized): string {\n        function formatProperty(prop: PropertyPreview): any {\n            switch (prop.type) {\n                case 'string':\n                case 'undefined':\n                    return inspectUtil(prop.value, opts);\n\n                case 'number':\n                case 'boolean':\n                    return opts.stylize(prop.value as string, prop.type);\n\n                case 'object':\n                case 'symbol':\n                    if (prop.subtype === 'date') {\n                        return inspectUtil(new Date(prop.value as string), opts);\n                    }\n                    if (prop.subtype === 'array') {\n                        return opts.stylize(prop.value as string, 'special');\n                    }\n                    return opts.stylize(prop.value as string, (prop.subtype as Style) || 'special');\n\n                default:\n                    return prop.value;\n            }\n        }\n\n        switch (this.type) {\n            case 'boolean':\n            case 'number':\n            case 'string':\n            case 'undefined':\n                return inspectUtil(this.value, opts);\n\n            case 'symbol':\n                return opts.stylize(this.description as string, 'special');\n\n            case 'function': {\n                const fnName = extractFunctionName(this.description);\n                const formatted = `[${this.className}${fnName}]`;\n                return opts.stylize(formatted, 'special');\n            }\n\n            case 'object':\n                switch (this.subtype) {\n                    case 'date':\n                        return inspectUtil(new Date(this.description as string), opts);\n\n                    case 'null':\n                        return inspectUtil(null, opts);\n\n                    case 'regexp':\n                        return opts.stylize(this.description as string, 'regexp');\n\n                    default:\n                        break;\n                }\n                if (this.preview) {\n                    const props: any[] = this.preview.properties.map((prop, idx) => {\n                        const value = formatProperty(prop);\n                        if (prop.name === `${idx}`) {\n                            return value;\n                        }\n                        return `${prop.name}: ${value}`;\n                    });\n                    if (this.preview.overflow) {\n                        props.push('...');\n                    }\n                    const singleLine = props.join(', ');\n                    const propString = singleLine.length > 60 ? props.join(',\\n  ') : singleLine;\n\n                    return this.subtype === 'array' ? `[ ${propString} ]` : `{ ${propString} }`;\n                }\n                return this.description || '';\n\n            default:\n                return this.description || '';\n        }\n    }\n\n    static fromEvalResult({ result, wasThrown }: { result: RemoteObject; wasThrown?: boolean }): RemoteObject | Error {\n        if (wasThrown) {\n            return convertResultToError(result);\n        }\n        return new RemoteObject(result);\n    }\n}\n\nclass ScopeSnapshot implements Debugger.Scope {\n    /**\n     * Scope type.\n     */\n    type: string;\n    /**\n     * Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties.\n     */\n    object: Runtime.RemoteObject;\n\n    name?: string | undefined;\n    /**\n     * Location in the source code where scope starts\n     */\n    startLocation?: Debugger.Location | undefined;\n    /**\n     * Location in the source code where scope ends\n     */\n    endLocation?: Debugger.Location | undefined;\n\n    properties: Map<string, RemoteObject>;\n\n    completionGroup: string[];\n\n    constructor(scope: Debugger.Scope, properties: Runtime.PropertyDescriptor[]) {\n        this.type = scope.type;\n        this.object = scope.object;\n\n        Object.assign(this, scope);\n\n        this.properties = new Map(\n            properties.map(prop => {\n                const value = new RemoteObject(prop.value);\n                return [prop.name, value];\n            }),\n        );\n\n        this.completionGroup = properties.map(prop => prop.name);\n    }\n\n    [inspectUtil.custom](_depth: number, opts: InspectOptions): string {\n        const type = `${this.type[0].toUpperCase()}${this.type.slice(1)}`;\n        const name = this.name ? `<${this.name}>` : '';\n        const prefix = `${type}${name} `;\n        return inspectUtil(this.properties, opts).replace(/^Map /, prefix);\n    }\n}\n/*\nfunction copyOwnProperties(target: any, source: any): void {\n    Object.getOwnPropertyNames(source).forEach(prop => {\n        const descriptor = Object.getOwnPropertyDescriptor(source, prop);\n        if (descriptor) {\n            Object.defineProperty(target, prop, descriptor);\n        }\n    });\n}\n\nfunction aliasProperties(target, mapping) {\n    Object.keys(mapping).forEach((key) => {\n        const descriptor = Object.getOwnPropertyDescriptor(target, key);\n        Object.defineProperty(target, mapping[key], descriptor);\n    });\n}\n*/\nexport default function createRepl(inspector: NodeInspector): () => REPLServer {\n    const { Debugger, /*HeapProfiler, Profiler,*/ Runtime } = inspector;\n\n    let repl: REPLServer;\n\n    // Things we want to keep around\n    // const history = { control: [], debug: [] };\n    // const watchedExpressions = [];\n    // const knownBreakpoints = [];\n    // let pauseOnExceptionState = 'none';\n    let lastCommand: string;\n\n    // Things we need to reset when the app restarts\n    let knownScripts: Record<string, Debugger.ScriptParsedEventDataType & { isNative: boolean }> = {};\n    let currentBacktrace: CallFrame[] | undefined;\n    let selectedFrame: CallFrame | undefined;\n    let exitDebugRepl: undefined | (() => void);\n\n    function resetOnStart(): void {\n        knownScripts = {};\n        currentBacktrace = undefined;\n        selectedFrame = undefined;\n\n        if (exitDebugRepl) {\n            exitDebugRepl();\n        }\n        exitDebugRepl = undefined;\n    }\n\n    resetOnStart();\n\n    const INSPECT_OPTIONS: InspectOptions = { colors: inspector.stdout.isTTY };\n    function inspect(value: any): string {\n        return inspectUtil(value, INSPECT_OPTIONS);\n    }\n\n    function print(value: any, oneline = false): void {\n        const text = typeof value === 'string' ? value : inspect(value);\n        return inspector.print(text, oneline);\n    }\n\n    function getCurrentLocation(): Debugger.Location {\n        if (!selectedFrame) {\n            throw new Error('Requires execution to be paused');\n        }\n        return selectedFrame.location;\n    }\n\n    function isCurrentScript(script: Debugger.ScriptParsedEventDataType & { isNative: boolean }): boolean {\n        return !!selectedFrame && getCurrentLocation().scriptId === script.scriptId;\n    }\n\n    function formatScripts(displayNatives = false): string {\n        function isVisible(script: Debugger.ScriptParsedEventDataType & { isNative: boolean }): boolean {\n            if (displayNatives) {\n                return true;\n            }\n            return !script.isNative || isCurrentScript(script);\n        }\n\n        return Object.keys(knownScripts)\n            .map(scriptId => knownScripts[scriptId])\n            .filter(isVisible)\n            .map(script => {\n                const isCurrent = isCurrentScript(script);\n                const { isNative, url } = script;\n                const name = `${getRelativePath(url)}${isNative ? ' <native>' : ''}`;\n                return `${isCurrent ? '*' : ' '} ${script.scriptId}: ${name}`;\n            })\n            .join('\\n');\n    }\n    function listScripts(displayNatives = false): void {\n        print(formatScripts(displayNatives));\n    }\n    // @ts-expect-error no idea what this is\n    listScripts[inspectUtil.custom] = function listWithoutInternal(): string {\n        return formatScripts();\n    };\n    /*\n    const profiles = [];\n    class Profile {\n        constructor(data) {\n            this.data = data;\n        }\n\n        static createAndRegister({ profile }) {\n            const p = new Profile(profile);\n            profiles.push(p);\n            return p;\n        }\n\n        [util.inspect.custom](depth, { stylize }) {\n            const { startTime, endTime } = this.data;\n            return stylize(`[Profile ${endTime - startTime}Î¼s]`, 'special');\n        }\n\n        save(filename = 'node.cpuprofile') {\n            const absoluteFile = Path.resolve(filename);\n            const json = JSON.stringify(this.data);\n            FS.writeFileSync(absoluteFile, json);\n            print('Saved profile to ' + absoluteFile);\n        }\n    }\n*/\n    class SourceSnippet {\n        scriptSource: string;\n        /**\n         * Script identifier as reported in the <code>Debugger.scriptParsed</code>.\n         */\n        scriptId: Runtime.ScriptId;\n        /**\n         * Line number in the script (0-based).\n         */\n        lineNumber: number;\n        /**\n         * Column number in the script (0-based).\n         */\n        columnNumber: number;\n        delta: number;\n        constructor(location: Debugger.Location, delta: number, scriptSource: string) {\n            this.lineNumber = location.lineNumber;\n            this.columnNumber = location.columnNumber || 0;\n            this.scriptId = location.scriptId;\n            this.scriptSource = scriptSource;\n            this.delta = delta;\n            Object.assign(this, location);\n        }\n\n        [inspectUtil.custom](_depth: number, options: InspectOptions): string {\n            const { /* scriptId, */ lineNumber, columnNumber, delta, scriptSource } = this;\n            const start = Math.max(1, lineNumber - delta + 1);\n            const end = lineNumber + delta + 1;\n\n            const lines = scriptSource.split('\\n');\n            return lines\n                .slice(start - 1, end)\n                .map((lineText, offset) => {\n                    const i = start + offset;\n                    const isCurrent = i === lineNumber + 1;\n\n                    const markedLine = isCurrent ? markSourceColumn(lineText, columnNumber, options.colors) : lineText;\n\n                    /*\n                let isBreakpoint = false;\n                knownBreakpoints.forEach(({ location }) => {\n                    if (!location) return;\n                    if (scriptId === location.scriptId &&\n                        i === (location.lineNumber + 1)) {\n                        isBreakpoint = true;\n                    }\n                });\n                */\n\n                    let prefixChar = ' ';\n                    if (isCurrent) {\n                        prefixChar = '>';\n                    } /*else if (isBreakpoint) {\n                    prefixChar = '*';\n                }*/\n                    return `${leftPad(i, prefixChar, end)} ${markedLine}`;\n                })\n                .join('\\n');\n        }\n    }\n\n    function getSourceSnippet(location: Debugger.Location, delta: number = 5): SourceSnippet {\n        const { scriptId } = location;\n        return Debugger.getScriptSource({ scriptId }).then(\n            ({ scriptSource }: Debugger.GetScriptSourceReturnType) => new SourceSnippet(location, delta, scriptSource),\n        );\n    }\n\n    class CallFrame implements Debugger.CallFrame {\n        /**\n         * Call frame identifier. This identifier is only valid while the virtual machine is paused.\n         */\n        callFrameId: Debugger.CallFrameId;\n        /**\n         * Name of the JavaScript function called on this call frame.\n         */\n        functionName: string;\n        /**\n         * Location in the source code.\n         */\n        functionLocation?: Debugger.Location | undefined;\n        /**\n         * Location in the source code.\n         */\n        location: Debugger.Location;\n        /**\n         * JavaScript script name or url.\n         */\n        url: string;\n        /**\n         * Scope chain for this call frame.\n         */\n        scopeChain: Debugger.Scope[];\n        /**\n         * <code>this</code> object for this call frame.\n         */\n        this: Runtime.RemoteObject;\n        /**\n         * The value being returned if the function is at return point.\n         */\n        returnValue?: Runtime.RemoteObject | undefined;\n\n        constructor(callFrame: Debugger.CallFrame) {\n            this.functionName = callFrame.functionName;\n            this.url = callFrame.url;\n            this.scopeChain = callFrame.scopeChain;\n            this.this = callFrame.this;\n            this.returnValue = callFrame.returnValue;\n            this.location = callFrame.location;\n            this.callFrameId = callFrame.callFrameId;\n\n            Object.assign(this, callFrame);\n        }\n\n        loadScopes(): Promise<ScopeSnapshot[]> {\n            return Promise.all(\n                this.scopeChain\n                    .filter(scope => scope.type !== 'global')\n                    .map(scope => {\n                        const { objectId } = scope.object;\n                        return Runtime.getProperties({\n                            objectId,\n                            generatePreview: true,\n                        } as Runtime.GetPropertiesParameterType).then(({ result }: Runtime.GetPropertiesReturnType) => {\n                            return new ScopeSnapshot(scope, result);\n                        });\n                    }),\n            );\n        }\n\n        list(delta: number = 5): SourceSnippet {\n            return getSourceSnippet(this.location, delta);\n        }\n    }\n\n    class Backtrace extends Array {\n        [inspectUtil.custom](): string {\n            return this.map((callFrame, idx) => {\n                const {\n                    location: { scriptId, lineNumber, columnNumber },\n                    functionName,\n                } = callFrame;\n                const name = functionName || '(anonymous)';\n\n                const script = knownScripts[scriptId];\n                const relativeUrl = (script && getRelativePath(script.url)) || '<unknown>';\n                const frameLocation = `${relativeUrl}:${lineNumber + 1}:${columnNumber}`;\n\n                return `#${idx} ${name} ${frameLocation}`;\n            }).join('\\n');\n        }\n\n        static from(callFrames: CallFrame[]): CallFrame[] {\n            return super.from(\n                Array.from(callFrames).map(callFrame => {\n                    if (callFrame instanceof CallFrame) {\n                        return callFrame;\n                    }\n                    return new CallFrame(callFrame);\n                }),\n            );\n        }\n    }\n\n    function prepareControlCode(input: string): string {\n        if (input === '\\n') {\n            return lastCommand;\n        }\n        // exec process.title => exec(\"process.title\");\n        const match = input.match(/^\\s*exec\\s+([^\\n]*)/);\n        if (match) {\n            lastCommand = `exec(${JSON.stringify(match[1])})`;\n        } else {\n            lastCommand = input;\n        }\n        return lastCommand;\n    }\n\n    // function evalInCurrentContext(code) {\n    //     // Repl asked for scope variables\n    //     if (code === '.scope') {\n    //         if (!selectedFrame) {\n    //             return Promise.reject(new Error('Requires execution to be paused'));\n    //         }\n    //         return selectedFrame.loadScopes().then((scopes) => {\n    //             return scopes.map((scope) => scope.completionGroup);\n    //         });\n    //     }\n    //\n    //     if (selectedFrame) {\n    //         return Debugger.evaluateOnCallFrame({\n    //             callFrameId: selectedFrame.callFrameId,\n    //             expression: code,\n    //             objectGroup: 'node-inspect',\n    //             generatePreview: true,\n    //         }).then(RemoteObject.fromEvalResult);\n    //     }\n    //     return Runtime.evaluate({\n    //         expression: code,\n    //         objectGroup: 'node-inspect',\n    //         generatePreview: true,\n    //     }).then(RemoteObject.fromEvalResult);\n    // }\n\n    function controlEval(\n        input: string,\n        context: Context,\n        filename: string,\n        callback: (error: Error | null, result?: any) => void,\n    ): void {\n        debuglog('eval:', input);\n        function returnToCallback(error: Error | null, result?: any): void {\n            debuglog('end-eval:', input, error);\n            callback(error, result);\n        }\n\n        try {\n            const code = prepareControlCode(input);\n            const result = runInContext(code, context, filename);\n\n            if (result && typeof result.then === 'function') {\n                toCallback(result, returnToCallback);\n                return;\n            }\n            returnToCallback(null, result);\n        } catch (e: any) {\n            returnToCallback(e as Error);\n        }\n    }\n\n    // function debugEval(input, context, filename, callback) {\n    //     debuglog('eval:', input);\n    //     function returnToCallback(error, result) {\n    //         debuglog('end-eval:', input, error);\n    //         callback(error, result);\n    //     }\n    //\n    //     try {\n    //         const result = evalInCurrentContext(input);\n    //\n    //         if (result && typeof result.then === 'function') {\n    //             toCallback(result, returnToCallback);\n    //             return;\n    //         }\n    //         returnToCallback(null, result);\n    //     } catch (e) {\n    //         returnToCallback(e);\n    //     }\n    // }\n\n    /*function formatWatchers(verbose = false) {\n        if (!watchedExpressions.length) {\n            return Promise.resolve('');\n        }\n\n        const inspectValue = (expr) =>\n            evalInCurrentContext(expr)\n                // .then(formatValue)\n                .catch((error) => `<${error.message}>`);\n        const lastIndex = watchedExpressions.length - 1;\n\n        return Promise.all(watchedExpressions.map(inspectValue))\n            .then((values) => {\n                const lines = watchedExpressions\n                    .map((expr, idx) => {\n                        const prefix = `${leftPad(idx, ' ', lastIndex)}: ${expr} =`;\n                        const value = inspect(values[idx], { colors: true });\n                        if (value.indexOf('\\n') === -1) {\n                            return `${prefix} ${value}`;\n                        }\n                        return `${prefix}\\n    ${value.split('\\n').join('\\n    ')}`;\n                    });\n                return lines.join('\\n');\n            })\n            .then((valueList) => {\n                return verbose ? `Watchers:\\n${valueList}\\n` : valueList;\n            });\n    }*/\n\n    //function watchers(verbose = false) {\n    //    return formatWatchers(verbose).then(print);\n    //}\n\n    // List source code\n    // function list(delta = 5) {\n    //     return selectedFrame.list(delta)\n    //         .then(null, (error) => {\n    //             print('You can\\'t list source code right now');\n    //             throw error;\n    //         });\n    // }\n\n    //function handleBreakpointResolved({ breakpointId, location }) {\n    //     const script = knownScripts[location.scriptId];\n    //     const scriptUrl = script && script.url;\n    //     if (scriptUrl) {\n    //         Object.assign(location, { scriptUrl });\n    //     }\n    //     const isExisting = knownBreakpoints.some((bp) => {\n    //         if (bp.breakpointId === breakpointId) {\n    //             Object.assign(bp, { location });\n    //             return true;\n    //         }\n    //         return false;\n    //     });\n    //     if (!isExisting) {\n    //         knownBreakpoints.push({ breakpointId, location });\n    //     }\n    //}\n\n    // function listBreakpoints() {\n    //     if (!knownBreakpoints.length) {\n    //         print('No breakpoints yet');\n    //         return;\n    //     }\n    //\n    //     function formatLocation(location) {\n    //         if (!location) return '<unknown location>';\n    //         const script = knownScripts[location.scriptId];\n    //         const scriptUrl = script ? script.url : location.scriptUrl;\n    //         return `${getRelativePath(scriptUrl)}:${location.lineNumber + 1}`;\n    //     }\n    //     const breaklist = knownBreakpoints\n    //         .map((bp, idx) => `#${idx} ${formatLocation(bp.location)}`)\n    //         .join('\\n');\n    //     print(breaklist);\n    // }\n\n    // function setBreakpoint(script, line, condition, silent) {\n    //     function registerBreakpoint({ breakpointId, actualLocation }) {\n    //         handleBreakpointResolved({ breakpointId, location: actualLocation });\n    //         if (actualLocation && actualLocation.scriptId) {\n    //             if (!silent) return getSourceSnippet(actualLocation, 5);\n    //         } else {\n    //             print(`Warning: script '${script}' was not loaded yet.`);\n    //         }\n    //         return undefined;\n    //     }\n    //\n    //     // setBreakpoint(): set breakpoint at current location\n    //     if (script === undefined) {\n    //         return Debugger\n    //             .setBreakpoint({ location: getCurrentLocation(), condition })\n    //             .then(registerBreakpoint);\n    //     }\n    //\n    //     // setBreakpoint(line): set breakpoint in current script at specific line\n    //     if (line === undefined && typeof script === 'number') {\n    //         const location = {\n    //             scriptId: getCurrentLocation().scriptId,\n    //             lineNumber: script - 1,\n    //         };\n    //         return Debugger.setBreakpoint({ location, condition })\n    //             .then(registerBreakpoint);\n    //     }\n    //\n    //     if (typeof script !== 'string') {\n    //         throw new TypeError(`setBreakpoint() expects a string, got ${script}`);\n    //     }\n    //\n    //     // setBreakpoint('fn()'): Break when a function is called\n    //     if (script.endsWith('()')) {\n    //         const debugExpr = `debug(${script.slice(0, -2)})`;\n    //         const debugCall = selectedFrame\n    //             ? Debugger.evaluateOnCallFrame({\n    //                 callFrameId: selectedFrame.callFrameId,\n    //                 expression: debugExpr,\n    //                 includeCommandLineAPI: true,\n    //             })\n    //             : Runtime.evaluate({\n    //                 expression: debugExpr,\n    //                 includeCommandLineAPI: true,\n    //             });\n    //         return debugCall.then(({ result, wasThrown }) => {\n    //             if (wasThrown) return convertResultToError(result);\n    //             return undefined; // This breakpoint can't be removed the same way\n    //         });\n    //     }\n    //\n    //     // setBreakpoint('scriptname')\n    //     let scriptId = null;\n    //     let ambiguous = false;\n    //     if (knownScripts[script]) {\n    //         scriptId = script;\n    //     } else {\n    //         for (const id of Object.keys(knownScripts)) {\n    //             const scriptUrl = knownScripts[id].url;\n    //             if (scriptUrl && scriptUrl.indexOf(script) !== -1) {\n    //                 if (scriptId !== null) {\n    //                     ambiguous = true;\n    //                 }\n    //                 scriptId = id;\n    //             }\n    //         }\n    //     }\n    //\n    //     if (ambiguous) {\n    //         print('Script name is ambiguous');\n    //         return undefined;\n    //     }\n    //     if (line <= 0) {\n    //         print('Line should be a positive value');\n    //         return undefined;\n    //     }\n    //\n    //     if (scriptId !== null) {\n    //         const location = { scriptId, lineNumber: line - 1 };\n    //         return Debugger.setBreakpoint({ location, condition })\n    //             .then(registerBreakpoint);\n    //     }\n    //\n    //     const escapedPath = script.replace(/([/\\\\.?*()^${}|[\\]])/g, '\\\\$1');\n    //     const urlRegex = `^(.*[\\\\/\\\\\\\\])?${escapedPath}$`;\n    //\n    //     return Debugger\n    //         .setBreakpointByUrl({ urlRegex, lineNumber: line - 1, condition })\n    //         .then((bp) => {\n    //             // TODO: handle bp.locations in case the regex matches existing files\n    //             if (!bp.location) { // Fake it for now.\n    //                 Object.assign(bp, {\n    //                     actualLocation: {\n    //                         scriptUrl: `.*/${script}$`,\n    //                         lineNumber: line - 1,\n    //                     },\n    //                 });\n    //             }\n    //             return registerBreakpoint(bp);\n    //         });\n    // }\n    //\n    // function clearBreakpoint(url, line) {\n    //     const breakpoint = knownBreakpoints.find(({ location }) => {\n    //         if (!location) return false;\n    //         const script = knownScripts[location.scriptId];\n    //         if (!script) return false;\n    //         return (\n    //             script.url.indexOf(url) !== -1 && (location.lineNumber + 1) === line\n    //         );\n    //     });\n    //     if (!breakpoint) {\n    //         print(`Could not find breakpoint at ${url}:${line}`);\n    //         return Promise.resolve();\n    //     }\n    //     return Debugger.removeBreakpoint({ breakpointId: breakpoint.breakpointId })\n    //         .then(() => {\n    //             const idx = knownBreakpoints.indexOf(breakpoint);\n    //             knownBreakpoints.splice(idx, 1);\n    //         });\n    // }\n    //\n    // function restoreBreakpoints() {\n    //     const lastBreakpoints = knownBreakpoints.slice();\n    //     knownBreakpoints.length = 0;\n    //     const newBreakpoints = lastBreakpoints\n    //         .filter(({ location }) => !!location.scriptUrl)\n    //         .map(({ location }) =>\n    //             setBreakpoint(location.scriptUrl, location.lineNumber + 1));\n    //     if (!newBreakpoints.length) return Promise.resolve();\n    //     return Promise.all(newBreakpoints).then((results) => {\n    //         print(`${results.length} breakpoints restored.`);\n    //     });\n    // }\n\n    // function setPauseOnExceptions(state) {\n    //     return Debugger.setPauseOnExceptions({ state })\n    //         .then(() => {\n    //             pauseOnExceptionState = state;\n    //         });\n    // }\n\n    Debugger.on('paused', (data: Debugger.PausedEventDataType): void => {\n        const callFrames: CallFrame[] = data.callFrames as CallFrame[];\n        const reason: string = data.reason;\n\n        if (process.env.NODE_INSPECT_RESUME_ON_START === '1' && reason === 'Break on start') {\n            debuglog('Paused on start, but NODE_INSPECT_RESUME_ON_START environment variable is set to 1, resuming');\n            inspector.client.callMethod('Debugger.resume');\n            return;\n        }\n\n        // Save execution context's data\n        currentBacktrace = Backtrace.from(callFrames);\n        selectedFrame = currentBacktrace[0];\n        const { scriptId, lineNumber } = selectedFrame.location;\n\n        const breakType = reason === 'other' ? 'break' : reason;\n        const script = knownScripts[scriptId];\n        const scriptUrl = script ? getRelativePath(script.url) : '[unknown]';\n\n        const header = `${breakType} in ${scriptUrl}:${lineNumber + 1}`;\n\n        void inspector.suspendReplWhile(() =>\n            Promise.all([/*formatWatchers(true), */ selectedFrame?.list(3)])\n                .then(([/*watcherList, */ context]) => {\n                    /*if (watcherList) {\n                        return `${watcherList}\\n${inspect(context)}`;\n                    }*/\n                    return inspect(context);\n                })\n                .then(breakContext => {\n                    print(`${header}\\n${breakContext}`);\n                }),\n        );\n    });\n\n    function handleResumed(): void {\n        currentBacktrace = undefined;\n        selectedFrame = undefined;\n    }\n\n    Debugger.on('resumed', handleResumed);\n\n    //Debugger.on('breakpointResolved', handleBreakpointResolved);\n\n    Debugger.on('scriptParsed', (script: Debugger.ScriptParsedEventDataType) => {\n        const { scriptId, url } = script;\n        if (url) {\n            knownScripts[scriptId] = Object.assign(\n                {\n                    isNative: isNativeUrl(url),\n                },\n                script,\n            );\n        }\n    });\n\n    /*Profiler.on('consoleProfileFinished', ({ profile }) => {\n        Profile.createAndRegister({ profile });\n        print([\n            'Captured new CPU profile.',\n            `Access it with profiles[${profiles.length - 1}]`\n        ].join('\\n'));\n    });*/\n\n    function initializeContext(context: Context): void {\n        Object.defineProperty(context, 'Debugger', {\n            value: inspector.Debugger,\n            enumerable: true,\n            configurable: true,\n            // @ts-expect-error fix later\n            writeable: false,\n        });\n        Object.defineProperty(context, 'HeapProfiler', {\n            value: inspector.HeapProfiler,\n            enumerable: true,\n            configurable: true,\n            // @ts-expect-error fix later\n            writeable: false,\n        });\n        Object.defineProperty(context, 'Profiler', {\n            value: inspector.Profiler,\n            enumerable: true,\n            configurable: true,\n            // @ts-expect-error fix later\n            writeable: false,\n        });\n        Object.defineProperty(context, 'Runtime', {\n            value: inspector.Runtime,\n            enumerable: true,\n            configurable: true,\n            // @ts-expect-error fix later\n            writeable: false,\n        });\n\n        /*copyOwnProperties(context, {\n            get help() {\n                print(HELP);\n            },\n\n            get run() {\n                return inspector.run();\n            },\n\n            get kill() {\n                return inspector.killChild();\n            },\n\n            get restart() {\n                return inspector.run();\n            },\n\n            get cont() {\n                handleResumed();\n                return Debugger.resume();\n            },\n\n            get next() {\n                handleResumed();\n                return Debugger.stepOver();\n            },\n\n            get step() {\n                handleResumed();\n                return Debugger.stepInto();\n            },\n\n            get out() {\n                handleResumed();\n                return Debugger.stepOut();\n            },\n\n            get pause() {\n                return Debugger.pause();\n            },\n\n            get backtrace() {\n                return currentBacktrace;\n            },\n\n            get breakpoints() {\n                return listBreakpoints();\n            },\n\n            exec(expr) {\n                return evalInCurrentContext(expr);\n            },\n\n            get profile() {\n                return Profiler.start();\n            },\n\n            get profileEnd() {\n                return Profiler.stop()\n                    .then(Profile.createAndRegister);\n            },\n\n            get profiles() {\n                return profiles;\n            },\n\n            takeHeapSnapshot(filename = 'node.heapsnapshot') {\n                return new Promise((resolve, reject) => {\n                    const absoluteFile = Path.resolve(filename);\n                    const writer = FS.createWriteStream(absoluteFile);\n                    let sizeWritten = 0;\n                    function onProgress({ done, total, finished }) {\n                        if (finished) {\n                            print('Heap snaphost prepared.');\n                        } else {\n                            print(`Heap snapshot: ${done}/${total}`, true);\n                        }\n                    }\n                    function onChunk({ chunk }) {\n                        sizeWritten += chunk.length;\n                        writer.write(chunk);\n                        print(`Writing snapshot: ${sizeWritten}`, true);\n                    }\n                    function onResolve() {\n                        writer.end(() => {\n                            teardown();\n                            print(`Wrote snapshot: ${absoluteFile}`);\n                            resolve();\n                        });\n                    }\n                    function onReject(error) {\n                        teardown();\n                        reject(error);\n                    }\n                    function teardown() {\n                        HeapProfiler.removeListener(\n                            'reportHeapSnapshotProgress', onProgress);\n                        HeapProfiler.removeListener('addHeapSnapshotChunk', onChunk);\n                    }\n\n                    HeapProfiler.on('reportHeapSnapshotProgress', onProgress);\n                    HeapProfiler.on('addHeapSnapshotChunk', onChunk);\n\n                    print('Heap snapshot: 0/0', true);\n                    HeapProfiler.takeHeapSnapshot({ reportProgress: true })\n                        .then(onResolve, onReject);\n                });\n            },\n\n            get watchers() {\n                return watchers();\n            },\n\n            watch(expr) {\n                watchedExpressions.push(expr);\n            },\n\n            unwatch(expr) {\n                const index = watchedExpressions.indexOf(expr);\n\n                // Unwatch by expression\n                // or\n                // Unwatch by watcher number\n                watchedExpressions.splice(index !== -1 ? index : +expr, 1);\n            },\n\n            get repl() {\n                // Don't display any default messages\n                const listeners = repl.listeners('SIGINT').slice(0);\n                repl.removeAllListeners('SIGINT');\n\n                const oldContext = repl.context;\n\n                exitDebugRepl = () => {\n                    // Restore all listeners\n                    process.nextTick(() => {\n                        listeners.forEach((listener) => {\n                            repl.on('SIGINT', listener);\n                        });\n                    });\n\n                    // Exit debug repl\n                    repl.eval = controlEval;\n\n                    // Swap history\n                    history.debug = repl.history;\n                    repl.history = history.control;\n\n                    repl.context = oldContext;\n                    repl.setPrompt('debug> ');\n                    repl.displayPrompt();\n\n                    repl.removeListener('SIGINT', exitDebugRepl);\n                    repl.removeListener('exit', exitDebugRepl);\n\n                    exitDebugRepl = null;\n                };\n\n                // Exit debug repl on SIGINT\n                repl.on('SIGINT', exitDebugRepl);\n\n                // Exit debug repl on repl exit\n                repl.on('exit', exitDebugRepl);\n\n                // Set new\n                repl.eval = debugEval;\n                repl.context = {};\n\n                // Swap history\n                history.control = repl.history;\n                repl.history = history.debug;\n\n                repl.setPrompt('> ');\n\n                print('Press Ctrl + C to leave debug repl');\n                repl.displayPrompt();\n            },\n\n            get version() {\n                return Runtime.evaluate({\n                    expression: 'process.versions.v8',\n                    contextId: 1,\n                    returnByValue: true,\n                }).then(({ result }) => {\n                    print(result.value);\n                });\n            },\n\n            scripts: listScripts,\n\n            //setBreakpoint,\n            //clearBreakpoint,\n            setPauseOnExceptions,\n            get breakOnException() {\n                return setPauseOnExceptions('all');\n            },\n            get breakOnUncaught() {\n                return setPauseOnExceptions('uncaught');\n            },\n            get breakOnNone() {\n                return setPauseOnExceptions('none');\n            },\n\n            list,\n        });*/\n        //aliasProperties(context, SHORTCUTS);\n    }\n\n    function initAfterStart(): Promise<void> {\n        const setupTasks = [\n            Runtime.enable(),\n            //Profiler.enable(),\n            //Profiler.setSamplingInterval({ interval: 100 }),\n            Debugger.enable(),\n            Debugger.setPauseOnExceptions({ state: 'none' }),\n            Debugger.setAsyncCallStackDepth({ maxDepth: 1 }),\n            Debugger.setBlackboxPatterns({ patterns: [] }),\n            // Debugger.setPauseOnExceptions({ state: 'all' }),\n            //restoreBreakpoints(),\n            Runtime.runIfWaitingForDebugger(),\n        ];\n        return Promise.all(setupTasks);\n    }\n\n    return function startRepl(): REPLServer {\n        inspector.client.on('close', () => resetOnStart());\n        inspector.client.on('ready', () => {\n            initAfterStart().catch(err => {\n                print(`Error starting inspector: ${err.message}`);\n            });\n        });\n\n        const replOptions: ReplOptions = {\n            prompt: 'debug> ',\n            input: inspector.stdin,\n            output: inspector.stdout,\n            eval: controlEval,\n            useGlobal: false,\n            ignoreUndefined: true,\n        };\n\n        repl = start(replOptions);\n        initializeContext(repl.context);\n        repl.on('reset', initializeContext);\n\n        repl.defineCommand('interrupt', () => {\n            // We want this for testing purposes where sending CTRL-C can be tricky.\n            repl.emit('SIGINT');\n        });\n\n        // Init once for the initial connection\n        initAfterStart().catch(err => {\n            print(`Error starting inspector: ${err.message}`);\n        });\n\n        return repl;\n    };\n}\n"]}