{"version":3,"file":"typescriptTools.js","sourceRoot":"","sources":["../../src/lib/typescriptTools.ts"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport { dirname, join, normalize, relative } from 'node:path';\nimport {\n    type Statement,\n    isImportDeclaration,\n    isImportEqualsDeclaration,\n    isExportDeclaration,\n    isExportAssignment,\n    isTypeAliasDeclaration,\n    isInterfaceDeclaration,\n    isModuleDeclaration,\n    isEnumDeclaration,\n    isClassDeclaration,\n    isFunctionDeclaration,\n    isVariableStatement,\n    isExpressionStatement,\n    createSourceFile,\n    createPrinter,\n    transform,\n    ScriptTarget,\n    factory,\n    SyntaxKind,\n    type Modifier,\n    NodeFlags,\n    type ModuleDeclaration,\n    visitNode,\n    visitNodes,\n    isSourceFile,\n    EmitHint,\n    type NodeArray,\n    type TransformerFactory,\n    type SourceFile,\n    type TransformationContext,\n    type Transformer,\n} from 'typescript';\nimport { matchAll } from './tools';\n\n/**\n * Resolves all TypeScript lib files for the editor\n *\n * @param targetLib The lib to target (e.g., es2017)\n */\nexport function resolveTypescriptLibs(\n    targetLib: 'es2017' | 'es2018' | 'es2019' | 'es2020' | 'es2021' | 'es2022' | 'esnext',\n): Record<string, string> {\n    const typescriptLibRoot = dirname(require.resolve(`typescript/lib/lib.d.ts`));\n    const ret: Record<string, string> = {};\n\n    const libReferenceRegex = /\\/\\/\\/ <reference lib=[\"']([^\"']+)[\"'] \\/>/g;\n    const matchAllLibs = (str: string): string[] => matchAll(libReferenceRegex, str).map(groups => groups[0]);\n\n    const libQueue: string[] = [targetLib];\n    while (libQueue.length > 0) {\n        const libName = libQueue.shift();\n        const filename = `lib.${libName}.d.ts`;\n        // Read the file and remember it in the return dictionary\n        const fileContent = readFileSync(join(typescriptLibRoot, filename), 'utf8');\n        ret[filename] = fileContent;\n        // If this file references another lib file, we need to load that too\n        // A reference looks like this: /// <reference lib=\"es2015.core\" />\n        // Find all libs we have not loaded yet\n        matchAllLibs(fileContent)\n            .filter(lib => !(`lib.${lib}.d.ts` in ret))\n            .forEach(lib => libQueue.push(lib));\n    }\n\n    return ret;\n}\n\nfunction normalizeDTSImport(filename: string): string {\n    // An import is either...\n    // a normal import\n    if (filename.endsWith('.d.ts')) {\n        return filename;\n    }\n    // an extensionless import\n    if (existsSync(`${filename}.d.ts`)) {\n        return `${filename}.d.ts`;\n    }\n    // or a directory import\n    return join(filename, 'index.d.ts');\n}\n\n/**\n * Resolves the type declarations of a 3rd party package for the editor\n *\n * @param pkg The package whose typings we're interested in\n * @param adapterScopedPackageName the package name on the system\n * @param wrapInDeclareModule Whether the root file should be wrapped in `declare module \"<pkg>\" { ... }`\n * @returns The found declarations or undefined if none were found\n */\nexport function resolveTypings(\n    pkg: string,\n    adapterScopedPackageName: string,\n    wrapInDeclareModule?: boolean,\n): Record<string, string> | undefined {\n    let packageJsonPath: string | undefined;\n    let packageJson: Record<string, any> | undefined;\n    let rootTypings: string | undefined;\n    let pkgIncludesTypings = true;\n\n    function tryToLoadPackage(path: string): void {\n        try {\n            packageJsonPath = require.resolve(path);\n            packageJson = require(packageJsonPath);\n            rootTypings =\n                typeof (packageJson as Record<string, any>).types === 'string'\n                    ? (packageJson as Record<string, any>).types\n                    : typeof (packageJson as Record<string, any>).typings === 'string'\n                      ? (packageJson as Record<string, any>).typings\n                      : undefined;\n        } catch {\n            /* ignore */\n        }\n    }\n\n    // First, try to resolve the package itself in case it brings its own typings\n    tryToLoadPackage(`${adapterScopedPackageName}/package.json`);\n\n    // If that didn't work, try again with the @types version of the package\n    if (!rootTypings) {\n        tryToLoadPackage(`@types/${pkg}/package.json`);\n        pkgIncludesTypings = false;\n    }\n    // TODO: If that didn't work, download @types/<packagename> and retry the previous step\n\n    // Nothing to do here since we found no packages\n    if (!rootTypings) {\n        return undefined;\n    }\n\n    if (!packageJsonPath) {\n        return undefined;\n    }\n\n    const packageRoot: string = dirname(packageJsonPath);\n    const normalizeImportPath = (filename: string): string =>\n        normalize(\n            `node_modules/${pkgIncludesTypings ? adapterScopedPackageName : `@types/${pkg}`}/${relative(packageRoot, filename)}`,\n        ).replace(/\\\\/g, '/');\n\n    const ret: Record<string, string> = {};\n\n    // We need to look at `import/export ... from 'modulename'` and `/// <reference path='...' />`\n    const importDtsRegex = /^\\s*(?:import|export) .+ from [\"'](\\.+\\/[^\"']+)[\"']/g;\n    const pathReferenceRegex = /\\/\\/\\/ <reference path=[\"']([^\"']+)[\"'] \\/>/g;\n    const matchAllImports = (str: string): string[] =>\n        [...matchAll(importDtsRegex, str), ...matchAll(pathReferenceRegex, str)].map(groups => groups[0]);\n\n    // the paths are relative to the package.json - we need an absolute path to read the files\n    rootTypings = join(packageRoot, rootTypings);\n    // some @types packages specify `index` as their typings file instead of `index.d.ts`\n    rootTypings = normalizeDTSImport(rootTypings);\n\n    // include package.json in typings, so TypeScript can look up the correct entry point\n    const relativePath = `node_modules/${pkgIncludesTypings ? '' : '@types/'}${pkg}/package.json`.replace(/\\\\/g, '/');\n    ret[relativePath] = JSON.stringify(packageJson);\n\n    // Used to test whether a .d.ts file already uses \"declare module\" or not\n    const declareModuleRegex = /^\\s*declare module/gm;\n\n    // recursively load all typings\n    const definitionQueue = [rootTypings];\n    while (definitionQueue.length > 0) {\n        const filename: string = definitionQueue.shift() as string;\n        const dirName = dirname(filename);\n        // Read the file and remember it in the return dictionary\n        let fileContent: string;\n        try {\n            fileContent = readFileSync(filename, 'utf8');\n        } catch (e: any) {\n            // The typings are malformed\n            console.error(`Failed to load definitions for ${pkg}: ${e.toString()}`);\n            // Since we cannot use them, return undefined\n            return undefined;\n        }\n        // We need to store the filename relative to the base dir\n        const relativePath = normalizeImportPath(filename);\n        // If necessary, wrap the root typings (only those!)\n        ret[relativePath] =\n            wrapInDeclareModule && filename === rootTypings && !declareModuleRegex.test(fileContent)\n                ? `declare module \"${pkg}\" { ${fileContent} }`\n                : fileContent;\n        // If this file references another .d.ts file, we need to load that too\n        matchAllImports(fileContent)\n            // resolve the file relative to the current directory\n            .map(file => join(dirName, file))\n            // find out the correct path of the file we want to import\n            .map(normalizeDTSImport)\n            // Find all libs we have not loaded yet\n            .filter(file => !(normalizeImportPath(file) in ret))\n            .forEach(file => definitionQueue.push(file));\n    }\n    // Avoid returning empty declarations\n    if (Object.keys(ret).length === 0) {\n        return undefined;\n    }\n    return ret;\n}\n\n/**\n * @param s\n * @param isGlobal Whether this is a global script or a normal one\n */\nfunction mustBeHoisted(s: Statement & { modifiers?: Modifier[] }, isGlobal?: boolean): boolean {\n    return !!(\n        // Import/export statements must be moved to the top\n        (\n            isImportDeclaration(s) ||\n            isImportEqualsDeclaration(s) ||\n            isExportDeclaration(s) ||\n            isExportAssignment(s) ||\n            // as well as many declarations\n            isTypeAliasDeclaration(s) ||\n            isInterfaceDeclaration(s) ||\n            isModuleDeclaration(s) ||\n            isEnumDeclaration(s) ||\n            (isGlobal &&\n                // in global scripts we don't wrap classes and functions, so they can be accessed from non-global scripts\n                (isClassDeclaration(s) || isFunctionDeclaration(s))) ||\n            // and declare ... / export ... statements\n            s.modifiers?.some(s => s.kind === SyntaxKind.DeclareKeyword || s.kind === SyntaxKind.ExportKeyword)\n        )\n    );\n}\n\nfunction canBeExported(s: Statement): boolean {\n    return (\n        // const, let, var\n        isVariableStatement(s) ||\n        // type, interface, enum, class, function\n        isTypeAliasDeclaration(s) ||\n        isInterfaceDeclaration(s) ||\n        isEnumDeclaration(s) ||\n        isClassDeclaration(s) ||\n        isFunctionDeclaration(s)\n    );\n}\n\nfunction addExportModifier(s: Statement & { modifiers?: Modifier[] }): Statement {\n    let modifiers: Modifier[] | undefined;\n    // Add export modifiers\n    if (!s.modifiers) {\n        modifiers = [factory.createModifier(SyntaxKind.ExportKeyword)];\n    } else if (!s.modifiers.some(m => m.kind === SyntaxKind.ExportKeyword)) {\n        modifiers = [...s.modifiers, factory.createModifier(SyntaxKind.ExportKeyword)];\n    } else {\n        return s;\n    }\n\n    if (isVariableStatement(s)) {\n        return factory.updateVariableStatement(s, modifiers, s.declarationList);\n    }\n    if (isTypeAliasDeclaration(s)) {\n        return factory.updateTypeAliasDeclaration(s, modifiers, s.name, s.typeParameters, s.type);\n    }\n    if (isInterfaceDeclaration(s)) {\n        return factory.updateInterfaceDeclaration(s, modifiers, s.name, s.typeParameters, s.heritageClauses, s.members);\n    }\n    if (isEnumDeclaration(s)) {\n        return factory.updateEnumDeclaration(s, modifiers, s.name, s.members);\n    }\n    if (isClassDeclaration(s)) {\n        return factory.updateClassDeclaration(s, modifiers, s.name, s.typeParameters, s.heritageClauses, s.members);\n    }\n    if (isFunctionDeclaration(s)) {\n        return factory.updateFunctionDeclaration(\n            s,\n            modifiers,\n            s.asteriskToken,\n            s.name,\n            s.typeParameters,\n            s.parameters,\n            s.type,\n            s.body,\n        );\n    }\n    return s;\n}\n\nfunction removeDeclareModifier(s: Statement & { modifiers?: Modifier[] }): Statement {\n    let modifiers: Modifier[] | undefined;\n    // Remove declare modifiers\n    if (s.modifiers) {\n        modifiers = s.modifiers.filter(m => m.kind !== SyntaxKind.DeclareKeyword);\n    } else {\n        return s;\n    }\n\n    if (isVariableStatement(s)) {\n        return factory.updateVariableStatement(s, modifiers, s.declarationList);\n    }\n    if (isTypeAliasDeclaration(s)) {\n        return factory.updateTypeAliasDeclaration(s, modifiers, s.name, s.typeParameters, s.type);\n    }\n    if (isInterfaceDeclaration(s)) {\n        return factory.updateInterfaceDeclaration(s, modifiers, s.name, s.typeParameters, s.heritageClauses, s.members);\n    }\n    if (isEnumDeclaration(s)) {\n        return factory.updateEnumDeclaration(s, modifiers, s.name, s.members);\n    }\n    if (isClassDeclaration(s)) {\n        return factory.updateClassDeclaration(s, modifiers, s.name, s.typeParameters, s.heritageClauses, s.members);\n    }\n    if (isFunctionDeclaration(s)) {\n        return factory.updateFunctionDeclaration(\n            s,\n            modifiers,\n            s.asteriskToken,\n            s.name,\n            s.typeParameters,\n            s.parameters,\n            s.type,\n            s.body,\n        );\n    }\n\n    return s;\n}\n\n// taken from node_modules\\@types\\node\\globals.d.ts\n// the globally available things must be wrapped in `declare global` if the user wants to augment them\nconst NodeJSGlobals = [\n    'Array',\n    'ArrayBuffer',\n    'Boolean',\n    'Buffer',\n    'DataView',\n    'Date',\n    'Error',\n    'EvalError',\n    'Float32Array',\n    'Float64Array',\n    'Function',\n    'GLOBAL',\n    'Infinity',\n    'Int16Array',\n    'Int32Array',\n    'Int8Array',\n    'Intl',\n    'JSON',\n    'Map',\n    'Math',\n    'NaN',\n    'Number',\n    'Object',\n    'Promise',\n    'RangeError',\n    'ReferenceError',\n    'RegExp',\n    'Set',\n    'String',\n    'Symbol',\n    'SyntaxError',\n    'TypeError',\n    'URIError',\n    'Uint16Array',\n    'Uint32Array',\n    'Uint8Array',\n    'Uint8ClampedArray',\n    'WeakMap',\n    'WeakSet',\n    'clearImmediate',\n    'clearInterval',\n    'clearTimeout',\n    'console',\n    'decodeURI',\n    'decodeURIComponent',\n    'encodeURI',\n    'encodeURIComponent',\n    'escape',\n    'eval',\n    'global',\n    'isFinite',\n    'isNaN',\n    'parseFloat',\n    'parseInt',\n    'process',\n    'root',\n    'setImmediate',\n    'setInterval',\n    'setTimeout',\n    'queueMicrotask',\n    'undefined',\n    'unescape',\n    'gc',\n    'v8debug',\n];\n\nfunction isGlobalAugmentation(s: Statement): boolean {\n    return !!(\n        (isInterfaceDeclaration(s) || isClassDeclaration(s) || isFunctionDeclaration(s)) &&\n        s.name &&\n        NodeJSGlobals.includes(s.name.text)\n    );\n}\n\nfunction wrapInDeclareGlobal(statements: Statement[]): ModuleDeclaration {\n    return factory.createModuleDeclaration(\n        [factory.createModifier(SyntaxKind.DeclareKeyword)],\n        factory.createIdentifier('global'),\n        factory.createModuleBlock(statements),\n        NodeFlags.GlobalAugmentation,\n    );\n}\n\n/**\n * Takes a TypeScript script and does the necessary transformations, so it can be compiled properly\n *\n * @param source The original TypeScript source\n * @param isGlobal Whether the transformed script is a global script or not\n */\nexport function transformScriptBeforeCompilation(source: string, isGlobal?: boolean): string {\n    const transformer: TransformerFactory<SourceFile> = (_context: TransformationContext): Transformer<SourceFile> => {\n        return (sourceFile: SourceFile) =>\n            visitNode(sourceFile, (node: SourceFile): any => {\n                if (isSourceFile(node)) {\n                    // Wrap all declarations that augment global interfaces in `declare global`\n                    const augmentations = node.statements.filter(s => isGlobalAugmentation(s));\n                    const nonAugmentations = node.statements.filter(s => !isGlobalAugmentation(s));\n\n                    // If there is no top level await, don't move all the statements around\n                    const hasTLA = node.statements.some(\n                        s => isExpressionStatement(s) && s.expression.kind === SyntaxKind.AwaitExpression,\n                    );\n                    // Move all statements to the top of the file that cannot appear in a function body\n                    let hoistedStatements = hasTLA\n                        ? factory.createNodeArray(nonAugmentations.filter(s => mustBeHoisted(s, isGlobal)))\n                        : factory.createNodeArray(nonAugmentations);\n\n                    // The rest gets wrapped\n                    const wrappedStatements = hasTLA ? nonAugmentations.filter(s => !mustBeHoisted(s, isGlobal)) : [];\n\n                    // When transforming global scripts, we need to do a couple of things\n                    if (isGlobal) {\n                        // 1. We need to add an export modifier to everything at the top level that can be exported\n                        hoistedStatements = visitNodes(\n                            hoistedStatements,\n                            // @ts-expect-error s is definitely a Statement\n                            s => (canBeExported(s) ? addExportModifier(s) : s),\n                        ) as NodeArray<Statement>;\n                        // 3. We need to transform the generated declarations to use `declare global` (this will happen in transformGlobalDeclarations)\n                    }\n                    const needsEmptyExport =\n                        // An empty export is necessary when there is no import declaration\n                        !node.statements.some(s => isImportDeclaration(s) || isImportEqualsDeclaration(s)) &&\n                        // And there is no statement in a global script which had an export modifier added\n                        (!(\n                            isGlobal &&\n                            hoistedStatements.some(\n                                // @ts-expect-error s should have modifiers\n                                s => s.modifiers?.some(m => m.kind === SyntaxKind.ExportKeyword),\n                            )\n                        ) ||\n                            // Or if there is a `declare global` statement\n                            !!augmentations);\n\n                    return factory.updateSourceFile(node, [\n                        // Put the hoisted statements at the top (or all of them if there's no top level await)\n                        ...hoistedStatements,\n                        // Then add everything that augments the global scope\n                        ...(augmentations && augmentations.length ? [wrapInDeclareGlobal(augmentations)] : []),\n                        ...(hasTLA\n                            ? // If there is a top-level await, wrap all non-hoisted statements in (async () => { ... })();\n                              [\n                                  factory.createExpressionStatement(\n                                      factory.createCallExpression(\n                                          factory.createArrowFunction(\n                                              [factory.createModifier(SyntaxKind.AsyncKeyword)],\n                                              undefined,\n                                              [],\n                                              undefined,\n                                              undefined,\n                                              factory.createBlock(wrappedStatements),\n                                          ),\n                                          undefined,\n                                          undefined,\n                                      ),\n                                  ),\n                              ]\n                            : []),\n                        ...(needsEmptyExport\n                            ? [\n                                  // Put an empty export {}; at the bottom to force TypeScript to treat the script as a module\n                                  factory.createExportDeclaration(\n                                      undefined, // ModifierLike[] | undefined\n                                      false, // isTypeOnly\n                                      factory.createNamedExports([]), // NamedExportBindings | undefined\n                                      undefined, // moduleSpecifier\n                                      undefined, // attributes\n                                  ),\n                              ]\n                            : []),\n                    ]);\n                }\n                return node;\n            });\n    };\n\n    const sourceFile = createSourceFile('index.ts', source, ScriptTarget.ESNext, /* setParentNodes */ true);\n\n    const result = transform(sourceFile, [transformer]);\n    return createPrinter().printNode(EmitHint.Unspecified, result.transformed[0], sourceFile);\n}\n\n/**\n * Takes the global declarations for a TypeScript and wraps export statements in `declare global`\n *\n * @param decl The untransformed global declarations\n */\nexport function transformGlobalDeclarations(decl: string): string {\n    const transformer: TransformerFactory<SourceFile> = (_context: TransformationContext): any => {\n        return (sourceFile: SourceFile) =>\n            visitNode(sourceFile, (node: SourceFile): SourceFile => {\n                if (isSourceFile(node)) {\n                    // All non-export-statements stay at the root level, the rest is wrapped in `declare global`\n                    const exportStatements = node.statements.filter(\n                        // @ts-expect-error s should have modifiers\n                        s => s.modifiers?.some(m => m.kind === SyntaxKind.ExportKeyword),\n                    );\n                    const otherStatements = node.statements.filter(s => !exportStatements.includes(s));\n\n                    const hasExportStatements = exportStatements.length > 0;\n                    const hasImport = otherStatements.some(s => isImportDeclaration(s) || isImportEqualsDeclaration(s));\n\n                    return factory.updateSourceFile(node, [\n                        ...otherStatements,\n                        ...(hasExportStatements\n                            ? [wrapInDeclareGlobal(exportStatements.map(s => removeDeclareModifier(s)))]\n                            : []),\n                        ...(hasImport\n                            ? [] // If there is an import, the script is already treated as a module\n                            : [\n                                  // Otherwise, put an empty export {}; at the bottom to force TypeScript to treat the script as a module\n                                  factory.createExportDeclaration(\n                                      undefined,\n                                      false,\n                                      factory.createNamedExports([]),\n                                      undefined,\n                                      undefined,\n                                  ),\n                              ]),\n                    ]);\n                }\n\n                return node;\n            });\n    };\n\n    const sourceFile = createSourceFile('index.d.ts', decl, ScriptTarget.ESNext, /* setParentNodes */ true);\n\n    const result = transform(sourceFile, [transformer]);\n    return createPrinter().printNode(EmitHint.Unspecified, result.transformed[0], sourceFile);\n}\n\n/**\n * Translates a script ID to a filename for the compiler\n *\n * @param scriptID The ID of the script\n */\nexport function scriptIdToTSFilename(scriptID: string): string {\n    return `${scriptID.replace(/^script.js./, '').replace(/\\./g, '/')}.ts`;\n}\n"]}